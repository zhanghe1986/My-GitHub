Java code:

spring xml:
<bean id="memoryStore" class="com.hikvision.cms.cache.manager.MemoryStore" autowire="byName" />
	<bean id="dbStore" class="com.hikvision.cms.cache.manager.MemoryStore" autowire="byName" />
	<bean id="thirdPartyStore" class="com.hikvision.cms.cache.manager.MemcacheStore" autowire="byName" />
<bean id="thirdPartyStore" class="com.hikvision.cms.cache.manager.RedisStore" />

package com.hikvision.cms.cache.manager;

import com.hikvision.cms.cache.core.common.CacheConstants.DATA_TYPE;

/**
 * 使用缓存的接口
 * @version V1.0
 */
public interface IDataStore {
	
	final static int XML_MAX_LENGTH = 1000000;
	final static int BLOCK_LENGTH = 1000;
	final static String BIG_DATA_FLAG = "DATA_BLOCK_COUNT_";
	
	/**
	 * 将数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期
	 * @param key   键
	 * @param value 值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value) throws DataLoadException;
	
	/**
	 * 将数据存放入缓存中 永不过期
	 * @param key   键
	 * @param value 值
	 * @param type  存入数据的类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,DATA_TYPE type) throws DataLoadException;
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间(单位毫秒)
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp) throws DataLoadException;
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间和数据类型
	  * @param key    键
	 * @param value  值
	 * @param exp    过期时间(单位毫秒)
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp,DATA_TYPE type) throws DataLoadException;
	
	/**
	 * 获取指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key) throws DataLoadException;
	
	/**
	 * 获取指定键和数据类型的数据
	 * @param key    键
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key,DATA_TYPE type) throws DataLoadException;
	
	
	/**
	 * 删除指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key) throws DataLoadException;
	
	/**
	 * 删除指定键和数据类型的数据
	 * @param key   键
	 * @param type  值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key,DATA_TYPE type) throws DataLoadException;
	
	/**
	 * 将对象数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期<br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value) throws DataLoadException;
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间，默认数据类型为DATA_TYPE.TEMP <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp) throws DataLoadException;
	
	/**
	 * 将对象数据存放入缓存中并指定数据类型，数据永不过期 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param type    数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,DATA_TYPE type) throws DataLoadException;
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间和数据类型 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @param exp     过期时间
	 * @param type    数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp, DATA_TYPE type) throws DataLoadException;
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key   键
	 * @return
	 * @throws DataLoadException
	 */
	@Deprecated
	public Object getObject(String key) throws DataLoadException;
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key    键
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	@Deprecated
	public Object getObject(String key,DATA_TYPE type) throws DataLoadException;
}

package com.hikvision.cms.cache.manager;
import com.hikvision.cms.cache.core.common.CacheConstants.DATA_TYPE;
import com.ivms6.core.util.cm.ConfigManager;
/**
 * 数据管理的实现
 * @version V1.0   
 */
public class DataManager {
	private IDataStore memoryStore;
	private IDataStore dbStore;
	private IDataStore thirdPartyStore;
	private String config = null;
	public boolean isThirdStore(){
		if(config == null){
			config = ConfigManager.getConfiguration("cache-store", "cache.thirdpart");
		}
		if("true".equals(config)){
			return true;
		}else{
			return false;
		}
	}
	
	private IDataStore  getStore(boolean single){
		if(isThirdStore()){
			return thirdPartyStore;
		}else if(single){
			return memoryStore;
		}else{
			return dbStore;
		}
	}
	
	/**
	 * 将数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期
	 * @param key   键
	 * @param value 值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value) throws DataLoadException{
		return getStore(true).set(key, value);
	}
	
	/**
	 * 将数据存放入缓存中 永不过期
	 * @param key   键
	 * @param value 值
	 * @param type  存入数据的类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,DATA_TYPE type) throws DataLoadException{
		return getStore(true).set(key, value, type);
	}
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp) throws DataLoadException{
		return getStore(true).set(key, value, exp);
	}
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间和数据类型
	  * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp,DATA_TYPE type) throws DataLoadException{
		return getStore(true).set(key, value, exp, type);
	}
	
	/**
	 * 获取指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key) throws DataLoadException{
		return getStore(true).get(key);
	}
	
	/**
	 * 获取指定键和数据类型的数据
	 * @param key    键
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key,DATA_TYPE type) throws DataLoadException{
		return getStore(true).get(key, type);
	}
	
	/**
	 * 删除指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key) throws DataLoadException{
		return getStore(true).remove(key);
	}
	
	/**
	 * 删除指定键和数据类型的数据
	 * @param key   键
	 * @param type  值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key,DATA_TYPE type) throws DataLoadException{
		return getStore(true).remove(key, type);
	}
	
	/**
	 * 将对象数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期<br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value) throws DataLoadException{
		return getStore(true).setObject(key, value);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间，默认数据类型为DATA_TYPE.TEMP <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp) throws DataLoadException{
		return getStore(true).setObject(key, value, exp);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定数据类型，数据永不过期 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param type    数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,DATA_TYPE type) throws DataLoadException{
		return getStore(true).setObject(key, value, type);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间和数据类型 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @param exp     过期时间
	 * @param type    数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp, DATA_TYPE type) throws DataLoadException{
		return getStore(true).setObject(key, value, exp, type);
	}
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key   键
	 * @return
	 * @throws DataLoadException
	 */
	public Object getObject(String key) throws DataLoadException{
		return getStore(true).getObject(key);
	}
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key    键
	 * @param type   数据类型
	 * @return
	 * @throws DataLoadException
	 */
	public Object getObject(String key,DATA_TYPE type) throws DataLoadException{
		return getStore(true).getObject(key, type);
	}
	
	/**
	 * 将数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期
	 * @param key   键
	 * @param value 值
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,boolean single) throws DataLoadException{
		return getStore(single).set(key, value);
	}
	
	/**
	 * 将数据存放入缓存中 永不过期
	 * @param key   键
	 * @param value 值
	 * @param type  存入数据的类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).set(key, value, type);
	}
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp,boolean single) throws DataLoadException{
		return getStore(single).set(key, value, exp);
	}
	
	/**
	 * 将数据存放入缓存中 ,并指定过期时间和数据类型
	  * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @param type   数据类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean set(String key,String value,long exp,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).set(key, value, exp, type);
	}
	
	/**
	 * 获取指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key,boolean single) throws DataLoadException{
		return getStore(single).get(key);
	}
	
	/**
	 * 获取指定键和数据类型的数据
	 * @param key    键
	 * @param type   数据类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public String get(String key,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).get(key, type);
	}
	
	
	/**
	 * 删除指定键的数据，数据类型默认为DATA_TYPE.TEMP
	 * @param key  键
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key,boolean single) throws DataLoadException{
		return getStore(single).remove(key);
	}
	
	/**
	 * 删除指定键和数据类型的数据
	 * @param key   键
	 * @param type  值
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean remove(String key,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).remove(key, type);
	}
	
	/**
	 * 将对象数据存放入缓存中，默认数据类型为DATA_TYPE.TEMP 永不过期<br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,boolean single) throws DataLoadException{
		return getStore(single).setObject(key, value);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间，默认数据类型为DATA_TYPE.TEMP <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param exp    过期时间
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp,boolean single) throws DataLoadException{
		return getStore(single).setObject(key, value, exp);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定数据类型，数据永不过期 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key    键
	 * @param value  值
	 * @param type    数据类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).setObject(key, value, type);
	}
	
	/**
	 * 将对象数据存放入缓存中并指定过期时间和数据类型 <br>
	 * 对象序列化后的长度不能超过 1000000 Byte
	 * @param key     键
	 * @param value   值
	 * @param exp     过期时间
	 * @param type    数据类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public boolean setObject(String key,Object value,long exp, DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).setObject(key, value, exp, type);
	}
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key   键
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public Object getObject(String key,boolean single) throws DataLoadException{
		return getStore(single).getObject(key);
	}
	
	/**
	 * 获取指定键和数据类型的对象， 返回的是保存的对象类型，使用的时候需要进行强制转换
	 * @param key    键
	 * @param type   数据类型
	 * @param single 是否单个应用使用，如果要跨jvm多个应用使用个，则该值需要置为false
	 * @return
	 * @throws DataLoadException
	 */
	public Object getObject(String key,DATA_TYPE type,boolean single) throws DataLoadException{
		return getStore(single).getObject(key, type);
	}
	
	
    public IDataStore getMemoryStore() {
    	return memoryStore;
    }

    public void setMemoryStore(IDataStore memoryStore) {
    	this.memoryStore = memoryStore;
    }

    public IDataStore getDbStore() {
    	return dbStore;
    }

    public void setDbStore(IDataStore dbStore) {
    	this.dbStore = dbStore;
    }

    public IDataStore getThirdPartyStore() {
    	return thirdPartyStore;
    }

    public void setThirdPartyStore(IDataStore thirdPartyStore) {
    	this.thirdPartyStore = thirdPartyStore;
    }
}


package com.hikvision.cms.cache.manager;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;
import com.hikvision.cms.cache.core.common.CacheConstants.DATA_TYPE;
import com.hikvision.cms.cache.core.tools.KeyUtil;
import com.hikvision.cms.cache.manager.serialize.ObjectTranscoder;
import com.ivms6.core.util.CollectionUtils;
import com.ivms6.core.util.NumberUtils;
import com.ivms6.core.util.StringUtils;
import com.ivms6.core.util.cm.ConfigManager;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPubSub;
import redis.clients.jedis.JedisSentinelPool;

/**
 * 操作Redis缓存的接口实现类
 */
@SuppressWarnings("unchecked")
public class RedisStore implements IDataStoreForCollection {
	private Logger log = LoggerFactory.getLogger(RedisStore.class);
	JedisPool jedisPool;
	JedisSentinelPool jedisSentinelPool;
	boolean cluster=false;
	static int DEFAULT_PORT = 6379;

	public RedisStore() {
		String thirdpart = ConfigManager.getConfiguration("cache-store","cache.thirdpart");
		if("true".equals(thirdpart)){
			String server = ConfigManager.getConfiguration("cache-connect",
					"cache.cluster.0.server");
			server = server.trim().replaceAll(" +", " ");
			GenericObjectPoolConfig config = new GenericObjectPoolConfig();
			config.setMaxTotal(NumberUtils.toInt(ConfigManager.getConfiguration(
					"cache-connect", "cache.cluster.0.connection-pool-size"), 10));
			config.setMinIdle(NumberUtils.toInt(ConfigManager.getConfiguration(
					"cache-connect", "cache.cluster.0.connection-min-idle"), 2));
			config.setMaxIdle(NumberUtils.toInt(ConfigManager.getConfiguration(
					"cache-connect", "cache.cluster.0.connection-max-idle"), 5));
			String clusterType = ConfigManager.getConfiguration("cache-connect", "cache.deploy.default.cluster");
			if(clusterType !=null && clusterType.equals("1")){
				cluster = true;
				String masterName = ConfigManager.getConfiguration("cache-connect", "cache.cluster.master.name");
				if(log.isDebugEnabled()){
					if(masterName == null){
						log.error("redis cluster masterName null");
					}
				}
				Set<String> sentinels = new HashSet<String>();
				String [] IpAndPort = server.split(" ");
				for(String info: IpAndPort){
					sentinels.add(info);
				}
				jedisSentinelPool = new JedisSentinelPool(masterName, sentinels , config, 4000,ConfigManager.getConfiguration(
						"cache-connect", "cache.cluster.0.auth"));
			}else {
				String ip = server.split(":")[0];
				int port = NumberUtils.toInt(server.split(":")[1], DEFAULT_PORT);
				
				jedisPool = new JedisPool(config, ip, port, 4000, ConfigManager.getConfiguration(
						"cache-connect", "cache.cluster.0.auth"));
			}
		}
	}

	private Jedis getJedis() {
		
		if(cluster){
			return jedisSentinelPool.getResource();
		}
		return jedisPool.getResource();
	}

	private void returnJedis(Jedis jedis) {
		if (jedis != null)
			jedis.close();
	}

	private void returnBrokenJedis(Jedis jedis) {
		if(jedis != null){
			jedis.close();
		}
	}

	@Override
	public boolean set(String key, String value) throws DataLoadException {
		Jedis jedis = null;
		if(value == null){
			log.error("the key:"+key+" value is"+value);
			return false;
		}
		try {
			jedis = getJedis();
			jedis.set(KeyUtil.getKeyPre() + key, value);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
		return true;
	}

	@Override
	public boolean set(String key, String value, DATA_TYPE type)
			throws DataLoadException {
		return set(key, value);
	}

	@Override
	public boolean set(String key, String value, long exp)
			throws DataLoadException {
		if(value == null){
			log.error("the key:"+key+" value is"+value);
			return false;
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			jedis.setex(KeyUtil.getKeyPre() +key, (int) (exp / 1000), value);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
		return true;
	}

	@Override
	public boolean set(String key, String value, long exp, DATA_TYPE type)
			throws DataLoadException {
		return set(key, value, exp);
	}

	@Override
	public String get(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.get(KeyUtil.getKeyPre() +key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}

	}

	@Override
	public String get(String key, DATA_TYPE type) throws DataLoadException {
		return get(key);
	}

	@Override
	public boolean remove(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			jedis.del(KeyUtil.getKeyPre() +key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
		return true;
	}

	@Override
	public boolean remove(String key, DATA_TYPE type) throws DataLoadException {
		return remove(key);
	}

	@Override
	public boolean setObject(String key, Object value) throws DataLoadException {
		Jedis jedis = null;
		if(value == null){
			log.error("the key:"+key+" value is"+value);
			return false;
		}
		try {
			jedis = getJedis();
			key = KeyUtil.getKeyPre() +key;
			return jedis.set(key.getBytes(), ObjectTranscoder.serialize(value)) == "OK";
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public boolean setObject(String key, Object value, long exp)
			throws DataLoadException {
		Jedis jedis = null;
		if(value == null){
			log.error("the key:"+key+" value is"+value);
			return false;
		}
		try {
			jedis = getJedis();
			key = KeyUtil.getKeyPre() +key;
			return jedis.setex(key.getBytes(),ms2second(exp),ObjectTranscoder.serialize(value)) != "OK";
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public boolean setObject(String key, Object value, DATA_TYPE type)
			throws DataLoadException {
		return setObject(key, value);
	}

	@Override
	public boolean setObject(String key, Object value, long exp, DATA_TYPE type)
			throws DataLoadException {
		return setObject(key, value, exp);
	}

	@Override
	public Object getObject(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			key = KeyUtil.getKeyPre() +key;
			byte[] in = jedis.get(key.getBytes());  
			Object o = ObjectTranscoder.deserialize(in);  
			return o;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public Object getObject(String key, DATA_TYPE type)
			throws DataLoadException {
		return getObject(key);
	}
	
	@Override
	public Boolean exsit(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.exists(KeyUtil.getKeyPre() +key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public void rename(String key, String newKey) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			jedis.rename(KeyUtil.getKeyPre() +key, newKey);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public Set<String> keys(String pattern) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.keys(pattern);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public Long ttl(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.ttl(KeyUtil.getKeyPre() +key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public void setObjectForGeneric(String key, Object value)
			throws DataLoadException {
		if (value instanceof CharSequence) {
			set(key, value.toString());
		} else {
			set(key, JSON.toJSONString(value));
		}
	}
	
	@Override
	public void setObjectForGeneric(String key, Object value, long exp)
			throws DataLoadException {
		setObject(key, value);
	}

	@Override
	public <T> T getObjectForGeneric(String key, Class<T> clazz) throws DataLoadException {
		String jsonstr = get(key);
		if (StringUtils.isEmpty(jsonstr)) {
			return null;
		} else {
			return (T) JSON.parseObject(jsonstr, clazz);
		}
	}

	@Override
	public <T> List<T> getList(String key, Class<T> clazz) throws DataLoadException {
		String jsonstr = get(key);
		if (StringUtils.isEmpty(jsonstr)) {
			return Collections.emptyList();
		} else {
			return (List<T>) JSON.parseArray(jsonstr, clazz);
		}
	}

	@Override
	public <T> Set<T> getSet(String key, Class<T> clazz)
			throws DataLoadException {
		List<T> list = getList(key, clazz);
		if (CollectionUtils.isEmpty(list)) {
			return Collections.emptySet();
		}
		Set<T> set = new HashSet<T>();
		set.addAll(list);
		return set;
	}

	@Override
	public <T> void rpush(String key, T... values)
			throws DataLoadException {
		if (values == null || values.length == 0) {
			return;
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			for (T t : values) {
				if (t instanceof CharSequence) {
					jedis.rpush(key, (String[])values);
					break;
				}
				jedis.rpush(key, JSON.toJSONString(t));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> void lpush(String key, T... values)
			throws DataLoadException {
		if (values == null || values.length == 0) {
			return;
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			for (T t : values) {
				if (t instanceof CharSequence) {
					jedis.lpush(key, (String[])values);
					break;
				}
				jedis.lpush(key, JSON.toJSONString(t));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public Long llen(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.llen(key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public void lset(String key, long index, Object value)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (value instanceof CharSequence) {
				jedis.lset(key, index, (String)value);
			} else {
				jedis.lset(key, index, JSON.toJSONString(value));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> T lindex(String key, Class<T> clazz, long index)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (clazz == String.class) {
				return (T) jedis.lindex(key, index);
			} else {
				String str = jedis.lindex(key, index);
				return JSON.parseObject(str, clazz);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public void ltrim(String key, long start, long end)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			jedis.ltrim(key, start, end);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> T lpop(String key, Class<T> clazz)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (clazz == String.class) {
				return (T) jedis.lpop(key);
			} else {
				String str = jedis.lpop(key);
				return JSON.parseObject(str, clazz);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> T rpop(String key, Class<T> clazz)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (clazz == String.class) {
				return (T) jedis.rpop(key);
			} else {
				String str = jedis.rpop(key);
				return JSON.parseObject(str, clazz);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> List<T> lrange(String key, Class<T> clazz, int start, int end)
			throws DataLoadException {
		List<String> list = null;
		List<T> result = null;
		Jedis jedis = null;
		try {
			jedis = getJedis();
			list = jedis.lrange(key, start, end);
			if (CollectionUtils.isNotEmpty(list)) {
				if (clazz == String.class) {
					return (List<T>) list;
				} else {
					result = new ArrayList<T>();
					for (String str : list) {
						result.add(JSON.parseObject(str, clazz));
					}
				}
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> void sadd(String key, T... values) throws DataLoadException {
		if (values == null || values.length == 0) {
			return;
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			for (T t : values) {
				if (t instanceof CharSequence) {
					jedis.sadd(key, (String[])values);
					break;
				}
				jedis.sadd(key, JSON.toJSONString(t));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> void srem(String key, T value) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (value instanceof CharSequence) {
				jedis.srem(key, (String)value);
			} else {
				jedis.srem(key, JSON.toJSONString(value));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Boolean sismember(String key, T value) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (value instanceof CharSequence) {
				return jedis.sismember(key, (String)value);
			} else {
				return jedis.sismember(key, JSON.toJSONString(value));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Long scard(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.scard(key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> T spop(String key, Class<T> clazz) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			String str = jedis.spop(key);
			if (clazz == String.class) {
				return (T) str;
			} else {
				return (T) JSON.parseObject(str, clazz);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Set<T> smembers(String key, Class<T> clazz)
			throws DataLoadException {
		Set<String> set = null;
		Set<T> result = null;
		Jedis jedis = null;
		try {
			jedis = getJedis();
			set = jedis.smembers(key);
			if (CollectionUtils.isNotEmpty(set)) {
				if (clazz == String.class) {
					return (Set<T>) set;
				} else {
					result = new HashSet<T>();
					for (String str : set) {
						result.add(JSON.parseObject(str, clazz));
					}
				}
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Set<T> sinter(Class<T> clazz, String... keys)
			throws DataLoadException {
		Set<String> set = null;
		Set<T> result = null;
		Jedis jedis = null;
		try {
			jedis = getJedis();
			set = jedis.sinter(keys);
			if (CollectionUtils.isNotEmpty(set)) {
				if (clazz == String.class) {
					return (Set<T>) set;
				} else {
					result = new HashSet<T>();
					for (String str : set) {
						result.add(JSON.parseObject(str, clazz));
					}
				}
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Set<T> sunion(Class<T> clazz, String... keys)
			throws DataLoadException {
		Set<String> set = null;
		Set<T> result = null;
		Jedis jedis = null;
		try {
			jedis = getJedis();
			set = jedis.sunion(keys);
			if (CollectionUtils.isNotEmpty(set)) {
				if (clazz == String.class) {
					return (Set<T>) set;
				} else {
					result = new HashSet<T>();
					for (String str : set) {
						result.add(JSON.parseObject(str, clazz));
					}
				}
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Set<T> sdiff(Class<T> clazz, String... keys)
			throws DataLoadException {
		Set<String> set = null;
		Set<T> result = null;
		Jedis jedis = null;
		try {
			jedis = getJedis();
			set = jedis.sdiff(keys);
			if (CollectionUtils.isNotEmpty(set)) {
				if (clazz == String.class) {
					return (Set<T>) set;
				} else {
					result = new HashSet<T>();
					for (String str : set) {
						result.add(JSON.parseObject(str, clazz));
					}
				}
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> void hset(String key, String field, T value)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			if (value instanceof CharSequence) {
				jedis.hset(key, field, (String) value);
			} else {
				jedis.hset(key, field, JSON.toJSONString(value));
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> void hmset(String key, Map<String, T> map)
			throws DataLoadException {
		if (map == null || map.size() == 0) {
			return;
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			Map<String, String> jsonMap = null;
			for (Map.Entry<String, T> entry : map.entrySet()) {
				T value = entry.getValue();
				if (value instanceof CharSequence) {
					jedis.hmset(key, (Map<String, String>)map);
					break;
				}
				if (jsonMap == null) {
					jsonMap = new HashMap<String, String>();
				}
				jsonMap.put(entry.getKey(), JSON.toJSONString(value));
			}
			if (jsonMap != null) {
				jedis.hmset(key, jsonMap);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}
	
	@Override
	public <T> T hget(String key, Class<T> clazz, String field)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			String value = jedis.hget(key, field);
			if (value == null) {
				return null;
			}
			if (clazz == String.class) {
				return (T) value;
			} else {
				return JSON.parseObject(value, clazz);
			}
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> List<T> hmget(String key, Class<T> clazz, String... fields)
			throws DataLoadException {
		if (fields == null || fields.length == 0) {
			return Collections.emptyList();
		}
		Jedis jedis = null;
		try {
			jedis = getJedis();
			List<String> list = jedis.hmget(key, fields);
			if (CollectionUtils.isEmpty(list)) {
				return Collections.emptyList();
			}
			if (clazz == String.class) {
				return (List<T>) list;
			}
			List<T> result = new ArrayList<T>();
			for (String str : list) {
				result.add(JSON.parseObject(str, clazz));
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public Long hlen(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.hlen(key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public Set<String> hkeys(String key) throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			return jedis.hkeys(key);
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> List<T> hvals(String key, Class<T> clazz)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			List<String> list =  jedis.hvals(key);
			if (CollectionUtils.isEmpty(list)) {
				return Collections.emptyList();
			}
			if (clazz == String.class) {
				return (List<T>) list;
			}
			List<T> result = new ArrayList<T>();
			for (String str : list) {
				result.add(JSON.parseObject(str, clazz));
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	@Override
	public <T> Map<String, T> hgetAll(String key, Class<T> clazz)
			throws DataLoadException {
		Jedis jedis = null;
		try {
			jedis = getJedis();
			Map<String, String> map =  jedis.hgetAll(key);
			if (CollectionUtils.isEmpty(map)) {
				return Collections.emptyMap();
			}
			if (clazz == String.class) {
				return (Map<String, T>) map;
			}
			Map<String, T> result = new HashMap<String, T>();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				result.put(entry.getKey(), JSON.parseObject(key, clazz));
			}
			return result;
		} catch (Exception e) {
			returnBrokenJedis(jedis);
			throw new DataLoadException(e);
		} finally {
			returnJedis(jedis);
		}
	}

	public void subscribe(JedisPubSub jedisPubSub ,String...channels){
		Jedis jedis = getJedis();
		jedis.subscribe(jedisPubSub, channels);
		jedis.close();
	}
	
	public void publish(String channel, String message){
		Jedis jedis = getJedis();
		jedis.publish(channel, message);
		jedis.close();
	}
	
	public void psubscribe(JedisPubSub jedisPubSub ,final String...patterns){
		Jedis jedis = getJedis();
		jedis.psubscribe(jedisPubSub, patterns);
		jedis.close();
	}
	
	/**
	 * 毫秒转换为秒
     * @param expiry
     * @return
     */
    private int ms2second(long expiry) {
	    return (int)((expiry % 1000) > 0 ? (expiry / 1000 + 1) : (expiry / 1000+1));
    }
}

package com.hikvision.cms.cache.manager;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.hikvision.cms.cache.core.common.CacheConstants.DATA_TYPE;
import com.hikvision.cms.cache.core.memory.SimpleMemoryCache;
import com.hikvision.cms.cache.core.tools.KeyUtil;

/**
 * 将基本的配置放在内存中,不支持集群环境
 * <p>
 * 该实现有内存限制，大数据量的数据不适合放入其中。
 *
 * TODO:
 * Q1：暂时不支持过期，接下去会开发支持过期的方式。 * 
 * Q2:这里还要考虑缓存数据最大值的情况，如果超出最大值，通过一定策略来进行存放，fifo，lru等....使用lru实现
 * </p>
 * @version V1.0
 */
public class MemoryStore implements IDataStore {
	private Logger log = LoggerFactory.getLogger(MemoryStore.class);
	private static SimpleMemoryCache<String,TimeObject> dataStore = new SimpleMemoryCache<String,TimeObject>(10000);
	private static final long NEVER_EXPIRE = 30 * 24 * 60* 60 * 1000L;
	private static long checkTime = 0;
	private static final long CHECK_PERIOD = 1000 * 30;

	private boolean isNeedCheck(){
		long now = System.currentTimeMillis();
		if(now - checkTime > CHECK_PERIOD){
			log.info("start clear expire data.");
			ExpireDataCleaner cleaner = new ExpireDataCleaner();
			cleaner.start();
			checkTime = now;
			return true;
		}
		return false;
	}
	
	@Override
    public String get(String key) throws DataLoadException {
		isNeedCheck();
		
	    TimeObject value = dataStore.get(KeyUtil.getKeyPre()+key);
		if(value == null || value.isExpire()){
			return null;
		}
		return String.valueOf(value.getData());
    }

	@Override
    public boolean set(String key, String value) throws DataLoadException {
		 setObject(key, value);
	     return true;
    }

	@Override
    public boolean set(String key, String value, long exp) throws DataLoadException {
		setObject(key, value, exp);
	     return true;
    }

	@Override
    public boolean remove(String key){
	    dataStore.remove(KeyUtil.getKeyPre()+key);
	    return true;
    }

	@Override
    public String get(String key, DATA_TYPE type) throws DataLoadException {
	    return get(key);
    }

	@Override
    public boolean remove(String key, DATA_TYPE type) throws DataLoadException {
	    return remove(key);
    }

	@Override
    public boolean set(String key, String value, DATA_TYPE type) throws DataLoadException {
	    return set(key,value);
    }

	@Override
    public boolean set(String key, String value, long exp, DATA_TYPE type) throws DataLoadException {
	    return set(key,value,exp);
    }

	@Override
    public Object getObject(String key) throws DataLoadException {
		isNeedCheck();
		
		TimeObject value = dataStore.get(KeyUtil.getKeyPre()+key);
		if(value == null || value.isExpire()){
			return null;
		}
		return value.getData();
    }
	
	@Override
    public boolean setObject(String key, Object value) throws DataLoadException {
		TimeObject data = new TimeObject(value, NEVER_EXPIRE);
		long now = System.currentTimeMillis();
		data.setUpdateTime(now);
		dataStore.put(KeyUtil.getKeyPre()+key, data);
	    return true;
    }

	@Override
    public boolean setObject(String key, Object value, long exp) throws DataLoadException {
		TimeObject data = new TimeObject(value, exp);
		long now = System.currentTimeMillis();
		data.setUpdateTime(now);
		dataStore.put(KeyUtil.getKeyPre()+key, data);
	    return true;
    }

	@Override
    public boolean setObject(String key, Object value, long exp, DATA_TYPE type) throws DataLoadException {
		TimeObject data = new TimeObject(value, exp);
		long now = System.currentTimeMillis();
		data.setUpdateTime(now);
		dataStore.put(KeyUtil.getKeyPre()+key, data);
	    return true;
    }

	@Override
    public Object getObject(String key, DATA_TYPE type) throws DataLoadException {
		return getObject(key);
    }

	@Override
    public boolean setObject(String key, Object value, DATA_TYPE type) throws DataLoadException {
	    return setObject(key, value);
    }
	
	class TimeObject{
		private long updateTime = -1;
		private long expire = 0;
		private Object data;
		
		public boolean isExpire(){
			long now = System.currentTimeMillis();
			if(now > expire + updateTime){
				return true;
			}
			return false;
		}
		
		public TimeObject(Object data){
			this.data = data;
		}
		
		public TimeObject(Object data,long expire){
			this.data = data;
			this.expire = expire;
		}
		
        public long getUpdateTime() {
        	return updateTime;
        }
		
        public void setUpdateTime(long updateTime) {
        	this.updateTime = updateTime;
        }
		
        public long getExpire() {
        	return expire;
        }
		
        public void setExpire(long expire) {
        	this.expire = expire;
        }
		
        public Object getData() {
        	return data;
        }
		
        public void setData(Object data) {
        	this.data = data;
        }

		@Override
        public String toString() {
	        return String.valueOf(data);
        }
		
	}
	
	class ExpireDataCleaner extends Thread{
		
		private void putExpireData2List(Map<String,TimeObject> dataMap,List<String> container){
			if(dataMap == null || dataMap.size() < 1){
				return;
			}
			for(Map.Entry<String, TimeObject>entry : dataMap.entrySet()){
				String key = entry.getKey();
				TimeObject to = entry.getValue();
				if(to.isExpire()){
					if(log.isDebugEnabled()){
						log.debug("the value [{}] is expired",new Object[]{key});
					}
					container.add(key);
				}
			}
		}
		
		@Override
        public void run() {//比较过期时间，进行处理
			List<String> container = new ArrayList<String>();
			Map<String,TimeObject> edenMap = dataStore.getEdenMap();
			Map<String,TimeObject> longTermMap = dataStore.getLongTermMap();
			putExpireData2List(edenMap,container);
			putExpireData2List(longTermMap,container);
			dataStore.remove(container);
        }
	}
}


package com.hikvision.cms.cache.manager;
import java.io.UnsupportedEncodingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.hikvision.cms.cache.core.common.CacheConstants.DATA_TYPE;
import com.hikvision.cms.cache.core.exception.CacheConnectException;
import com.hikvision.cms.cache.core.tools.CacheUtil;
import com.hikvision.cms.cache.manager.serialize.XmlSerializer;
import com.ivms6.core.util.StringUtils;
import com.thoughtworks.xstream.XStreamException;

/**
 * 使用memcached来实现的缓存。
 * <p>
 * 其中数据类型为DATA_TYPE.SESSION的数据会有备份数据，其他数据只存一份<br>
 * 另外返回空为空，抛出异常为去服务器获取数据异常，需要区别对待<br>
 * </p>
 * @version V1.0
 */
public class MemcacheStore implements IDataStore {
	private Logger log = LoggerFactory.getLogger(MemcacheStore.class);
	private XmlSerializer serializer = new XmlSerializer();
	
	@Override
	public String get(String key) throws DataLoadException {
		try {
	        return (String)CacheUtil.get(key);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,"",e,"get");
	        throw new DataLoadException(e);
        }
	}
	
	//如果缓存不能够连接上，将缓存错误记录到数据库中
	private void recordSystemLog(String key, String value, Throwable ce, String action) {
		log.info("write system log for cache error.key:" + key + ",value:" + value);
    }
	
//	private Throwable getCauseException(Throwable e){
//		if (e.getCause() != null) {
//			return getCauseException(e.getCause());
//		}else{
//			return e;
//		}
//	}
	

	@Override
	public boolean set(String key, String value)  throws DataLoadException{
		return set(key,value,0);
	}

	@Override
    public boolean set(String key, String value, long exp) throws DataLoadException {
		try {
	        CacheUtil.set(key, value,exp);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,value,e,"set");
        	throw new DataLoadException(e);
        }
        return true;
    }

	@Override
    public boolean remove(String key) throws DataLoadException {
		try {
			CacheUtil.delete(key);
		 } catch (CacheConnectException e) {
	        	recordSystemLog(key,"",e,"remove");
	        	throw new DataLoadException(e);
	     }
	     return true;
    }

	@Override
    public String get(String key, DATA_TYPE type) throws DataLoadException {
		try {
	        return (String)CacheUtil.get(key,type);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,"",e,"get");
	       throw new DataLoadException(e);
        }
    }

	@Override
    public boolean remove(String key, DATA_TYPE type) throws DataLoadException {
		try {
			CacheUtil.delete(key,type);
		 } catch (CacheConnectException e) {
	        	recordSystemLog(key,"",e,"remove");
	        	throw new DataLoadException(e);
	     }
	     return true;
    }

	@Override
    public boolean set(String key, String value, DATA_TYPE type) throws DataLoadException {
		try {
	        CacheUtil.set(key, (Object)value,type);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,value,e,"set");
        	throw new DataLoadException(e);
        }
        return true;
    }

	@Override
    public boolean set(String key, String value, long exp, DATA_TYPE type) throws DataLoadException {
		try {
	        CacheUtil.set(key, (Object)value,exp,type);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,value,e,"set");
        	throw new DataLoadException(e);
        }
        return true;
    }
	@Override
    public Object getObject(String key) throws DataLoadException {
		return getObject(key,DATA_TYPE.TEMP);
    }

	@Override
    public boolean setObject(String key, Object value) throws DataLoadException {
		 return setObject(key,value,0,DATA_TYPE.TEMP);
    }

	@Override
    public boolean setObject(String key, Object value, long exp) throws DataLoadException {
	    return setObject(key,value,exp,DATA_TYPE.TEMP);
    }

	@Override
    public boolean setObject(String key, Object value, long exp, DATA_TYPE type) throws DataLoadException {
		String xml = "";
		try {
			xml =serializer.serialize(value);;
			if(StringUtils.isEmpty(xml)){
				return false;
			}
			try {
	            if(xml.getBytes("utf-8").length > XML_MAX_LENGTH){
	            	DataLoadException e = new DataLoadException("object is too big to save.");
	            	recordSystemLog(key,xml,e,"setObject");
	            	throw e;
	            }
            } catch (UnsupportedEncodingException e) {
            	recordSystemLog(key,xml,e,"setObject");
            	throw new DataLoadException("object is illegal.",e);
            }
	        CacheUtil.set(key, xml,exp,type);
        } catch (CacheConnectException e) {
        	recordSystemLog(key,xml,e,"setObject");
        	throw new DataLoadException(e);
        }catch(XStreamException e){
        	recordSystemLog(key,xml,e,"setObject");
        	throw new DataLoadException("serialized value error.",e);
        }
	    return false;
    }

	@Override
    public Object getObject(String key, DATA_TYPE type) throws DataLoadException {
		try {
	        String xml = (String)CacheUtil.get(key,type);
	        Object value = serializer.unSerialize(xml);
	        return value; 
        } catch (CacheConnectException e) {
        	recordSystemLog(key,"",e,"getObject");
        	throw new DataLoadException(e);
        } catch(XStreamException e){
        	recordSystemLog(key,"",e,"setObject");
        	throw new DataLoadException("deserialized value error.",e);
        }
    }

	@Override
    public boolean setObject(String key, Object value, DATA_TYPE type) throws DataLoadException {
	    return setObject(key, value, 0, type);
    }
}


